with frt_prep as (
            select *, row_number() over (partition by ticket_id order by created_date asc) as frt_idx
            from  {{ ref('fact_freshdesk_interactions') }} i
            -- We include every interaction that has 'customer' tag - these are all interactions created under 1 ticket on the customer side.
            -- The tag is added by the product team when creating the ticket (when order is sold)
            where ticket_tag = 'customer'
            -- here we exclude interactions that are notes added by people.
            -- the agent_id's are for Response notifier and Hubs Notification accounts
            and i.interaction_id not in (select i2.interaction_id
            from  {{ ref('fact_freshdesk_interactions') }} i2
            where (i2.interaction_type = 'note' and
                    agent_id not in ('13021854997', '13020021323')))
            -- The customer ticket interactions are now ranked excluding notes that are not relevant (internal notes for example)
            -- All other interactions are ranked with the simple logic excluding all notes
            union all
            select *, row_number() over (partition by ticket_id order by created_date asc) as frt_idx
            from  {{ ref('fact_freshdesk_interactions') }} i
            where interaction_type <> 'note'
            and ticket_tag != 'customer'
        --Notes are internal communication and so never considered an 'agent interaction'
        --However, for customer tickets, notes can often indicate the 'starting time' of something agents need to respond to
            order by ticket_id
    ),
     frt_transform as (
       select frt_prep.ticket_id,
               -- PO tickets are created at the time an order is sourced,
               -- so the conversation only begins at the time of the second interaction (frt_idx = 2)
               -- only need to measure FRT when the conversation is initiated by the supplier so we filter on type
               min(case
                       when frt_prep.source = 'portal' and ticket_tag = 'supplier' and frt_idx = 2
                           and
                            (interaction_type = 'customer reply' or from_email ~ 'notifier@(3d)?hubs.com')
                           then frt_prep.created_date::timestamp
                       else null end) as first_response_time_start_supplier,
            -- Customer tickets are now also created at the time the order is sold so the same logic applies.
            -- Customer team very often first reaction is initiated by a "Note" generated by the system so we need to include that when measuring their FRT.
            -- frt_index = 1 means creation of the ticket, frt = 2 means either a note asking them to act or a customer reaching out
               min(case
                       when (ticket_tag = 'customer' and interaction_type like 'customer%' and frt_idx=2)
                           or (ticket_tag = 'customer' and interaction_type = 'note' and sf.first_response_start_status_open_at::date =
                                                                                         frt_prep.created_date::date)

                           then frt_prep.created_date::timestamp
                       else null end) as first_response_time_start_customer,
            -- This will capture regular tickets where they are created when people reach out to us.
                 min(case
                       when ticket_tag = 'unknown' and frt_idx = 1
                           then frt_prep.created_date::timestamp
                       else null end) as first_response_time_start_other,
               --Here we want to capture the first agent reply for a ticket.
               --Filter out notifier because this is an automatic reply that is genertaed when the ticket is submitted
               min(case
                       when interaction_type = 'agent reply' and frt_idx > 1
                           and from_email !~ 'notifier@(3d)?hubs.com'
                           then frt_prep.created_date::timestamp
                       else null end) as first_reply_time
        from frt_prep
           left join {{ ref('stg_fact_freshdesk_tickets') }} sf on frt_prep.ticket_id = sf.ticket_id
             -- The "group by" here functions only to bring it all onto ticket level in a single row
             -- We always select only 1 row per condition because of frt_idx filter
        group by 1
     ),
        first_response_time as (
             select frt_transform.ticket_id,
                    coalesce(frt_transform.first_response_time_start_customer,
                             frt_transform.first_response_time_start_supplier,first_response_time_start_other)             as first_response_start_date,
                    case
                        when first_response_start_date is not null
                            then frt_transform.first_reply_time end                        as first_response_reply_date,
                    --we only want to expose first_response reply for tickets where it is relevant.
                    datediff('hour', first_response_start_date, first_response_reply_date) as first_response_time_in_hours
             from frt_transform
             inner join {{ ref('stg_fact_freshdesk_tickets') }}  ft on ft.ticket_id = frt_transform.ticket_id
         )
select distinct ft.ticket_id,
        ft.order_uuid,
        ft.subject,
        ft.created_date,
        ft."group",
        ft.ticket_agent_name,
        ft.customer_contact,
        ft.company,
        ft.category,
        ft.sub_category,
        ft.status,
        ft.priority,
        ft.source,
        ft.ticket_tag_3d_hubs,
        ft.resolved_date,
        ft.num_days_to_resolution,
        ft.survey_result_id,
        ft.survey_id,
        ft.customer_satisfaction_survey_agent_id,
        ft.customer_satisfaction_survey_agent_name,
        ft.customer_satisfaction_survey_id,
        ft.customer_satisfaction_survey_completed_at,
        ft.customer_satisfaction_score,
        ft.customer_satisfaction_score_technical_knowledge,
        ft.customer_satisfaction_score_friendliness,
        ft.customer_satisfaction,
        ft.customer_satisfaction_technical_knowledge,
        ft.customer_satisfaction_friendliness,
        ft.customer_satisfaction_feedback,
        ft.linked_ticket_id,
        ft.is_primary_ticket,
        ft.requester_email,
        ft.requester_email_domain,
        ft.value,
        -- Only populating first_response attributes for tickets that were not involved in a merge
        case when fme.ticket_id is null then frt.first_response_start_date end    first_response_start_date,
        case when fme.ticket_id is null then frt.first_response_reply_date end    first_response_reply_date,
        case when fme.ticket_id is null then frt.first_response_time_in_hours end first_response_time_in_hours,
        case when fme.ticket_id is not null then true else false end              is_involved_in_merge
from {{ ref('stg_fact_freshdesk_tickets') }} as ft
            left join first_response_time frt on ft.ticket_id = frt.ticket_id
            left join {{ ref('freshdesk_merge_events') }} as fme on ft.ticket_id = fme.ticket_id